<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스페이스 딜리버리Z</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to top, #000428, #004e92);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            color: white;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        #prepScreen {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 0 30px #00ffff;
            max-width: 900px;
        }
        
        .prep-header {
            font-size: 28px;
            color: #00ffff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .prep-section {
            background: rgba(0, 50, 100, 0.3);
            border: 2px solid #0088ff;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .section-title {
            font-size: 18px;
            color: #ffaa00;
            margin-bottom: 10px;
        }
        
        .cargo-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
        }
        
        .cargo-display {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffdd00;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 16px;
            color: #ffdd00;
        }
        
        .prep-button {
            background: linear-gradient(45deg, #0066cc, #0088ff);
            color: white;
            border: 2px solid #00aaff;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .prep-button:hover:not(:disabled) {
            background: linear-gradient(45deg, #0088ff, #00aaff);
            transform: scale(1.05);
        }
        
        .prep-button:disabled {
            background: #666;
            border-color: #888;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .start-mission {
            background: linear-gradient(45deg, #00aa00, #00cc00);
            color: white;
            border: 2px solid #00ff00;
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }
        
        .start-mission:hover:not(:disabled) {
            background: linear-gradient(45deg, #00cc00, #00ff00);
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ff00;
        }
        
        .start-mission:disabled {
            background: #666;
            border-color: #888;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        #gameCanvas {
            border: 2px solid #00ffff;
            background: radial-gradient(ellipse at center, #001122 0%, #000000 100%);
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameInfo {
            margin-top: 10px;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 1280px;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .upgrade-btn {
            background: linear-gradient(45deg, #ff6600, #ff8800);
            color: white;
            border: 2px solid #ffaa00;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            min-width: 120px;
            transition: all 0.3s;
        }
        
        .upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(45deg, #ff8800, #ffaa00);
            transform: scale(1.05);
        }
        
        .upgrade-btn:disabled {
            background: #666;
            border-color: #888;
            cursor: not-allowed;
            transform: none;
        }
        
        .destination-card {
            background: rgba(0, 100, 150, 0.3);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 12px;
        }
        
        .destination-card:hover {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .destination-card.selected {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
        }
        
        .dest-name {
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 5px;
        }
        
        .dest-time, .dest-difficulty, .dest-reward {
            margin: 2px 0;
            color: #ccc;
        }
        
        .cargo-type-card {
            background: rgba(150, 100, 0, 0.3);
            border: 2px solid #666;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 11px;
        }
        
        .cargo-type-card:hover {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }
        
        .cargo-type-card.selected {
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.2);
        }
        
        .cargo-name {
            font-weight: bold;
            color: #ffaa00;
            margin-bottom: 3px;
        }
        
        .cargo-effect {
            color: #00ff00;
            margin: 1px 0;
        }
        
        .cargo-penalty {
            color: #ff6666;
            margin: 1px 0;
        }
        
        .cargo-reward {
            color: #00ffff;
            margin: 1px 0;
            font-weight: bold;
        }
        
        .cargo-status {
            color: #888;
            margin: 2px 0;
            font-size: 10px;
            font-weight: bold;
        }
        
        .cargo-type-card.selected .cargo-status {
            color: #00ff00;
        }
        
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #00ff00;
            box-shadow: 0 0 30px #00ff00;
        }
        
        button {
            background: #00ffff;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #00dddd;
        }

        #envIndicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 3px 6px;
            font-size: 12px;
            border-radius: 4px;
            z-index: 1000;
        }

        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            display: none;
        }

        #touchControls button {
            width: 50px;
            height: 50px;
            margin: 5px;
            font-size: 20px;
            opacity: 0.7;
        }

        #touchControls #btn-fire {
            position: absolute;
            right: -80px;
            bottom: 0;
        }
    </style>
</head>
<body>
    <div id="envIndicator"></div>
    <div id="gameContainer">
        <!-- 준비 화면 -->
        <div id="prepScreen">
            <!-- 게임 타이틀 -->
            <div style="margin-bottom: 30px;">
                <svg width="600" height="120" viewBox="0 0 600 120" style="filter: drop-shadow(0 0 20px #00ffff);">
                    <!-- 배경 별들 -->
                    <circle cx="50" cy="20" r="1" fill="white" opacity="0.8"/>
                    <circle cx="120" cy="15" r="0.5" fill="white" opacity="0.6"/>
                    <circle cx="180" cy="25" r="1.5" fill="#ffff00" opacity="0.9"/>
                    <circle cx="250" cy="18" r="0.8" fill="white" opacity="0.7"/>
                    <circle cx="320" cy="22" r="1" fill="white" opacity="0.8"/>
                    <circle cx="420" cy="16" r="0.5" fill="white" opacity="0.6"/>
                    <circle cx="480" cy="24" r="1.2" fill="#ffff00" opacity="0.9"/>
                    <circle cx="550" cy="19" r="0.8" fill="white" opacity="0.7"/>
                    
                    <!-- SPACE 텍스트 -->
                    <defs>
                        <linearGradient id="spaceGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#00ffff;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#0088ff;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#0044ff;stop-opacity:1" />
                        </linearGradient>
                        <linearGradient id="deliveryGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffaa00;stop-opacity:1" />
                            <stop offset="50%" style="stop-color:#ff6600;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#ff0000;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <!-- SPACE -->
                    <text x="50" y="60" font-family="Arial Black, sans-serif" font-size="36" font-weight="bold" 
                          fill="url(#spaceGrad)" stroke="#00aaff" stroke-width="1">SPACE</text>
                    
                    <!-- DELIVERY -->
                    <text x="50" y="95" font-family="Arial Black, sans-serif" font-size="28" font-weight="bold" 
                          fill="url(#deliveryGrad)" stroke="#ffaa00" stroke-width="1">DELIVERY</text>
                    
                    <!-- Z -->
                    <text x="480" y="95" font-family="Arial Black, sans-serif" font-size="48" font-weight="bold" 
                          fill="#ffff00" stroke="#ff6600" stroke-width="2" 
                          style="filter: drop-shadow(0 0 10px #ffff00);">Z</text>
                    
                    <!-- 우주선 아이콘 -->
                    <g transform="translate(380, 35)">
                        <!-- 우주선 본체 -->
                        <polygon points="20,0 40,20 35,25 25,25 20,30 15,25 5,25 0,20" 
                                 fill="#00ffff" stroke="#ffffff" stroke-width="1"/>
                        <!-- 윙 -->
                        <polygon points="0,15 15,20 15,25 0,20" fill="#0088ff"/>
                        <polygon points="40,15 25,20 25,25 40,20" fill="#0088ff"/>
                        <!-- 엔진 -->
                        <circle cx="20" cy="32" r="3" fill="#ff6600"/>
                        <!-- 화물 박스들 -->
                        <rect x="12" y="18" width="4" height="4" fill="#8B4513" stroke="#654321"/>
                        <rect x="17" y="18" width="4" height="4" fill="#8B4513" stroke="#654321"/>
                        <rect x="22" y="18" width="4" height="4" fill="#8B4513" stroke="#654321"/>
                    </g>
                    
                    <!-- 다이아 아이콘 -->
                    <g transform="translate(540, 45)">
                        <polygon points="15,5 25,15 15,25 5,15" fill="#00ffff" stroke="#ffffff" stroke-width="1" 
                                 style="filter: drop-shadow(0 0 5px #00ffff);"/>
                        <polygon points="15,8 22,15 15,22 8,15" fill="#ffffff" opacity="0.6"/>
                    </g>
                    
                    <!-- 움직이는 별 효과 -->
                    <g opacity="0.8">
                        <animateTransform attributeName="transform" type="translate" 
                                        values="0,0; 20,0; 0,0" dur="3s" repeatCount="indefinite"/>
                        <circle cx="30" cy="35" r="0.8" fill="#ffff00"/>
                        <circle cx="80" cy="45" r="0.6" fill="white"/>
                        <circle cx="130" cy="40" r="1" fill="#ffff00"/>
                    </g>
                </svg>
            </div>
            
            <div class="prep-header">미션 준비 - 스테이지 <span id="prepStage">1</span></div>

            <div class="prep-section">
                <div class="section-title">💼 현재 골드: <span id="prepGold">100</span> | 💎 다이아: <span id="prepDiamonds">0</span></div>
            </div>

            <div class="prep-section">
                <div class="section-title">🖥️ 환경 선택</div>
                <div style="display: flex; justify-content: center; gap: 10px;">
                    <button class="prep-button" onclick="applyEnvironment('pc')">PC 해상도</button>
                    <button class="prep-button" onclick="applyEnvironment('mobile')">모바일 해상도</button>
                </div>
                <div style="text-align: center; margin-top: 5px; font-size: 14px;">
                    선택된 환경: <span id="selectedEnvDisplay">없음</span>
                </div>
            </div>

            <!-- 영구 업그레이드 -->
            <div class="prep-section">
                <div class="section-title">🔧 우주선 영구 업그레이드 (다이아)</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;">
                    <div style="background: rgba(0, 100, 150, 0.3); padding: 10px; border-radius: 8px; border: 1px solid #0088ff;">
                        <div style="font-weight: bold; color: #00ffff;">🚀 엔진 업그레이드</div>
                        <div style="font-size: 12px; color: #ccc;">레벨 <span id="shipSpeedLevel">1</span> | 기본속도 +<span id="speedBonus">0</span>%</div>
                        <button class="prep-button" onclick="upgradeShipSpeed()" style="width: 100%; margin-top: 5px;">
                            업그레이드 (<span id="speedUpgradeCost">5</span>💎)
                        </button>
                    </div>
                    <div style="background: rgba(0, 100, 150, 0.3); padding: 10px; border-radius: 8px; border: 1px solid #0088ff;">
                        <div style="font-weight: bold; color: #00ffff;">🎯 포탑 시스템</div>
                        <div style="font-size: 12px; color: #ccc;">레벨 <span id="maxTurretLevel">1</span> | 최대 <span id="maxTurrets">7</span>개</div>
                        <button class="prep-button" onclick="upgradeMaxTurrets()" style="width: 100%; margin-top: 5px;">
                            업그레이드 (<span id="turretUpgradeCost">8</span>💎)
                        </button>
                    </div>
                    <div style="background: rgba(0, 100, 150, 0.3); padding: 10px; border-radius: 8px; border: 1px solid #0088ff;">
                        <div style="font-weight: bold; color: #00ffff;">📦 화물 시스템</div>
                        <div style="font-size: 12px; color: #ccc;">레벨 <span id="cargoCapacityLevel">1</span> | 화물 슬롯 +<span id="cargoSlotBonus">0</span></div>
                        <button class="prep-button" onclick="upgradeCargoCapacity()" style="width: 100%; margin-top: 5px;">
                            업그레이드 (<span id="cargoUpgradeCost">10</span>💎)
                        </button>
                    </div>
                    <div style="background: rgba(0, 100, 150, 0.3); padding: 10px; border-radius: 8px; border: 1px solid #0088ff;">
                        <div style="font-weight: bold; color: #00ffff;">💣 기뢰 시스템</div>
                        <div style="font-size: 12px; color: #ccc;">보유: <span id="mineUpgradeOwned">아니오</span></div>
                        <button class="prep-button" onclick="unlockMines()" style="width: 100%; margin-top: 5px;">
                            업그레이드 (<span id="mineUpgradeCost">20</span>💎)
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 행선지 선택 -->
            <div class="prep-section">
                <div class="section-title">🚀 배송 목적지 선택</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 15px 0;">
                    <div class="destination-card" data-destination="nearby" onclick="handleDestinationClick('nearby')">
                        <div class="dest-name">🌍 근거리 행성</div>
                        <div class="dest-time">⏰ 2:00</div>
                        <div class="dest-difficulty">위험도: ⭐</div>
                        <div class="dest-reward">보상: 기본</div>
                    </div>
                    <div class="destination-card" data-destination="medium" onclick="handleDestinationClick('medium')">
                        <div class="dest-name">🪐 중거리 행성</div>
                        <div class="dest-time">⏰ 2:30</div>
                        <div class="dest-difficulty">위험도: ⭐⭐</div>
                        <div class="dest-reward">보상: +20%</div>
                    </div>
                    <div class="destination-card" data-destination="far" onclick="handleDestinationClick('far')">
                        <div class="dest-name">🌌 원거리 행성</div>
                        <div class="dest-time">⏰ 3:00</div>
                        <div class="dest-difficulty">위험도: ⭐⭐⭐</div>
                        <div class="dest-reward">보상: +50%</div>
                    </div>
                    <div class="destination-card" data-destination="dangerous" onclick="handleDestinationClick('dangerous')">
                        <div class="dest-name">⚠️ 위험 지역</div>
                        <div class="dest-time">⏰ 3:30</div>
                        <div class="dest-difficulty">위험도: ⭐⭐⭐⭐</div>
                        <div class="dest-reward">보상: +100%</div>
                    </div>
                </div>
                <div id="destinationInfo" style="background: rgba(0, 100, 0, 0.2); border: 1px solid #00aa00; border-radius: 5px; padding: 10px; margin: 10px 0; display: none;">
                    <strong>선택된 목적지:</strong> <span id="selectedDestName">없음</span><br>
                    <span id="selectedDestDesc">목적지를 선택해주세요.</span>
                </div>
            </div>
            
            <!-- 화물 타입 선택 -->
            <div class="prep-section">
                <div class="section-title" id="cargoSectionTitle">📦 화물 선택 (최대 2개)</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 15px 0;">
                    <div class="cargo-type-card" data-cargo="military" onclick="handleCargoClick('military')">
                        <div class="cargo-name">🔫 군사 물자</div>
                        <div class="cargo-effect">공격력 +50%</div>
                        <div class="cargo-penalty">적 어그로 +30%</div>
                        <div class="cargo-reward">💎 +15</div>
                        <div class="cargo-status" id="military-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="medical" onclick="handleCargoClick('medical')">
                        <div class="cargo-name">🏥 의료 용품</div>
                        <div class="cargo-effect">생명력 +1</div>
                        <div class="cargo-penalty">이동속도 -10%</div>
                        <div class="cargo-reward">💎 +10</div>
                        <div class="cargo-status" id="medical-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="energy" onclick="handleCargoClick('energy')">
                        <div class="cargo-name">⚡ 에너지 셀</div>
                        <div class="cargo-effect">연사속도 +30%</div>
                        <div class="cargo-penalty">폭발 위험</div>
                        <div class="cargo-reward">💎 +12</div>
                        <div class="cargo-status" id="energy-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="luxury" onclick="handleCargoClick('luxury')">
                        <div class="cargo-name">💎 고급품</div>
                        <div class="cargo-effect">다이아 +100%</div>
                        <div class="cargo-penalty">이동속도 -20%</div>
                        <div class="cargo-reward">💎 +25</div>
                        <div class="cargo-status" id="luxury-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="tech" onclick="handleCargoClick('tech')">
                        <div class="cargo-name">🔧 기술 부품</div>
                        <div class="cargo-effect">포탑 정확도 +25%</div>
                        <div class="cargo-penalty">무게 증가</div>
                        <div class="cargo-reward">💎 +18</div>
                        <div class="cargo-status" id="tech-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="fuel" onclick="handleCargoClick('fuel')">
                        <div class="cargo-name">⛽ 연료</div>
                        <div class="cargo-effect">이동속도 +20%</div>
                        <div class="cargo-penalty">화재 위험</div>
                        <div class="cargo-reward">💎 +8</div>
                        <div class="cargo-status" id="fuel-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="food" onclick="handleCargoClick('food')">
                        <div class="cargo-name">🍖 식량</div>
                        <div class="cargo-effect">순수 골드 보상</div>
                        <div class="cargo-penalty">패널티 없음</div>
                        <div class="cargo-reward">💰 +20</div>
                        <div class="cargo-status" id="food-status">선택 안됨</div>
                    </div>
                    <div class="cargo-type-card" data-cargo="art" onclick="handleCargoClick('art')">
                        <div class="cargo-name">🎨 예술품</div>
                        <div class="cargo-effect">순수 다이아 보상</div>
                        <div class="cargo-penalty">패널티 없음</div>
                        <div class="cargo-reward">💎 +15</div>
                        <div class="cargo-status" id="art-status">선택 안됨</div>
                    </div>
                </div>
                
                <div style="text-align: center; margin: 15px 0;">
                    <div class="cargo-display">
                        선택된 화물: <span id="selectedCargoCount">0</span>/<span id="maxCargoSlots">2</span> 종류
                    </div>
                    <div id="selectedCargoList" style="font-size: 14px; color: #ffdd00; margin-top: 10px; min-height: 40px; background: rgba(100, 100, 0, 0.2); border: 1px solid #ffaa00; border-radius: 5px; padding: 10px;">
                        <strong>선택된 화물 효과:</strong><br>
                        <span id="cargoEffectText">화물을 선택해주세요</span>
                    </div>
                    <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                        화물 카드를 클릭하여 선택/해제
                    </div>
                </div>
            </div>
            
            <button class="start-mission" onclick="startMission()" id="startMissionBtn" disabled>🚀 배송 미션 시작</button>
        </div>
        
        <!-- 게임 화면 -->
        <div id="gameScreen" style="display: none;">
            <canvas id="gameCanvas" width="1280" height="760"></canvas>
            <div id="touchControls">
                <div>
                    <button id="btn-up">▲</button>
                </div>
                <div>
                    <button id="btn-left">◀</button>
                    <button id="btn-down">▼</button>
                    <button id="btn-right">▶</button>
                </div>
                <button id="btn-fire">🔥</button>
            </div>
            <div id="gameInfo">
                <span>점수: <span id="score">0</span></span>
                <span>💰 골드: <span id="gold">100</span></span>
                <span>❤️ 생명: <span id="lives">3</span></span>
                <span>⏰ 시간: <span id="timer">180</span>초</span>
                <span>📦 화물: <span id="gameCargoInfo">없음</span></span>
                <span>🎯 포탑: <span id="turrets">1</span>개</span>
            </div>
            
            <div id="upgradePanel" style="margin-top: 15px; display: flex; justify-content: center; gap: 15px;">
                <button class="upgrade-btn" onclick="addTurret()">
                    🎯 포탑 추가<br><span style="font-size: 12px;">100골드</span>
                </button>
                <button class="upgrade-btn" onclick="upgradeDamage()">
                    ⚔️ 공격력 업그레이드<br><span style="font-size: 12px;" id="damageCost">50골드</span>
                </button>
                <button class="upgrade-btn" onclick="upgradeSpeed()">
                    ⚡ 공격속도 업그레이드<br><span style="font-size: 12px;" id="speedCost">75골드</span>
                </button>
            </div>
            
            <button onclick="returnToPrep()" style="margin-top: 15px;">🔙 준비화면으로</button>
        </div>
        
        <!-- 게임 오버 -->
        <div id="gameOverScreen" class="modal">
            <h2>💥 미션 실패!</h2>
            <p>스테이지: <span id="failedStage">1</span></p>
            <p>최종 점수: <span id="finalScore">0</span></p>
            <p>💰 골드가 모두 소실되었습니다!</p>
            <p>💎 다이아는 안전하게 보관됩니다</p>
            <button onclick="returnToPrep()">재도전</button>
        </div>
        
        <!-- 스테이지 클리어 -->
        <div id="stageCompleteScreen" class="modal">
            <h2>🎉 배송 성공! 🎉</h2>
            <p>운송한 화물: <span id="completedCargo">없음</span></p>
            <p>획득 골드: <span id="rewardGold">0</span></p>
            <p>💎 획득 다이아: <span id="rewardDiamonds">0</span></p>
            <button onclick="returnToPrep()">다음 배송 준비</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 목적지 정의
        const DESTINATIONS = {
            nearby: {
                name: '근거리 행성',
                description: '안전하지만 보상이 적습니다.',
                time: 120, // 2분
                difficulty: 1,
                rewards: {
                    goldMultiplier: 1,
                    diamondMultiplier: 1
                }
            },
            medium: {
                name: '중거리 행성',
                description: '적당한 위험과 보상입니다.',
                time: 150, // 2분 30초
                difficulty: 1.5,
                rewards: {
                    goldMultiplier: 1.2,
                    diamondMultiplier: 1.2
                }
            },
            far: {
                name: '원거리 행성',
                description: '위험하지만 보상이 좋습니다.',
                time: 180, // 3분
                difficulty: 2,
                rewards: {
                    goldMultiplier: 1.5,
                    diamondMultiplier: 1.5
                }
            },
            dangerous: {
                name: '위험 지역',
                description: '매우 위험하지만 최고의 보상!',
                time: 210, // 3분 30초
                difficulty: 3,
                rewards: {
                    goldMultiplier: 2,
                    diamondMultiplier: 2
                }
            }
        };
        
        // 화물 타입 정의
        const CARGO_TYPES = {
            military: {
                name: '🔫 군사 물자',
                description: '공격력 +50%, 적 출현율 +30%',
                effects: {
                    damageBonus: 0.5,
                    enemySpawnRate: 1.3
                },
                baseReward: 15
            },
            medical: {
                name: '🏥 의료 용품',
                description: '생명력 +1, 이동속도 -10%',
                effects: {
                    bonusLife: 1,
                    speedPenalty: 0.1
                },
                baseReward: 10
            },
            energy: {
                name: '⚡ 에너지 셀',
                description: '연사속도 +30%',
                effects: {
                    fireRateBonus: 0.3
                },
                baseReward: 12
            },
            luxury: {
                name: '💎 고급품',
                description: '다이아 보상 +100%, 이동속도 -20%',
                effects: {
                    diamondBonus: 1,
                    speedPenalty: 0.2
                },
                baseReward: 25
            },
            tech: {
                name: '🔧 기술 부품',
                description: '포탑 정확도 향상',
                effects: {
                    turretAccuracy: 0.25
                },
                baseReward: 18
            },
            fuel: {
                name: '⛽ 연료',
                description: '이동속도 +20%',
                effects: {
                    speedBonus: 0.2
                },
                baseReward: 8
            },
            food: {
                name: '🍖 식량',
                description: '골드 보상',
                effects: {},
                baseReward: 20
            },
            art: {
                name: '🎨 예술품',
                description: '다이아 보상',
                effects: {},
                baseReward: 15
            }
        };
        
        // 게임 상태
        let gameState = {
            score: 0,
            gold: 100,
            diamonds: 0,
            lives: 3,
            stage: 1,
            gameOver: false,
            stageComplete: false,
            inGame: false,
            cargoCount: 0,
            stageTimer: 180,
            lastTimerUpdate: 0,
            keys: {},
            lastEnemySpawn: 0,
            damageLevel: 1,
            speedLevel: 1,
            turretCount: 1,
            // 영구 업그레이드
            shipSpeedLevel: 1,
            maxTurretLevel: 1,
            cargoCapacityLevel: 1,
            mineLevel: 0,
            lastMineTime: 0,
            // 선택된 화물과 목적지
            selectedCargos: [],
            selectedDestination: null,
            environment: null
        };

        let mobileControlsInitialized = false;
        
        // 플레이어
        const player = {
            x: 640,
            y: 600,
            width: 160,
            height: 120,
            baseSpeed: 4,
            speed: 4,
            color: '#00ffff',
            turrets: []
        };
        
        // 게임 객체들
        let bullets = [];
        let turretBullets = [];
        let enemyBullets = [];
        let enemies = [];
        let explosions = [];
        let stars = [];
        let mines = [];
        let gameLoopRunning = false;
        
        // 오디오 컨텍스트
        let audioContext;
        let masterVolume = 0.3;
        
        // 오디오 초기화
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('오디오 컨텍스트를 생성할 수 없습니다:', e);
            }
        }
        
        // 효과음 생성 함수들
        function playShootSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(masterVolume * 0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function playTurretSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.08);
            
            gainNode.gain.setValueAtTime(masterVolume * 0.08, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.08);
        }
        
        function playExplosionSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(masterVolume * 0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function playHitSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(masterVolume * 0.15, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        function playUpgradeSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(masterVolume * 0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.2);
        }
        
        function playStageCompleteSound() {
            if (!audioContext) return;
            
            const notes = [523, 659, 784, 1047];
            
            notes.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.2);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.2);
                gainNode.gain.linearRampToValueAtTime(masterVolume * 0.15, audioContext.currentTime + index * 0.2 + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.2 + 0.3);
                
                oscillator.start(audioContext.currentTime + index * 0.2);
                oscillator.stop(audioContext.currentTime + index * 0.2 + 0.3);
            });
        }
        
        function playGameOverSound() {
            if (!audioContext) return;
            
            const notes = [392, 349, 311, 261];
            
            notes.forEach((freq, index) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.3);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.3);
                gainNode.gain.linearRampToValueAtTime(masterVolume * 0.2, audioContext.currentTime + index * 0.3 + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.3 + 0.5);
                
                oscillator.start(audioContext.currentTime + index * 0.3);
                oscillator.stop(audioContext.currentTime + index * 0.3 + 0.5);
            });
        }
        
        // 화물 선택 핸들러
        function handleCargoClick(cargoType) {
            console.log('화물 클릭:', cargoType);
            
            const maxSlots = getMaxCargoSlots();
            const currentIndex = gameState.selectedCargos.indexOf(cargoType);
            
            if (currentIndex !== -1) {
                gameState.selectedCargos.splice(currentIndex, 1);
                console.log('화물 제거:', cargoType);
            } else {
                if (gameState.selectedCargos.length < maxSlots) {
                    gameState.selectedCargos.push(cargoType);
                    console.log('화물 추가:', cargoType);
                } else {
                    console.log('최대 슬롯 초과');
                    return;
                }
            }
            
            updateCargoUI();
        }
        
        // 목적지 선택 핸들러
        function handleDestinationClick(destKey) {
            console.log('목적지 클릭:', destKey);
            gameState.selectedDestination = destKey;
            
            document.querySelectorAll('.destination-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            const selectedCard = document.querySelector(`[data-destination="${destKey}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }
            
            updatePrepUI();
        }
        
        // 화물 UI 업데이트
        function updateCargoUI() {
            const maxSlots = getMaxCargoSlots();
            
            document.getElementById('selectedCargoCount').textContent = gameState.selectedCargos.length;
            document.getElementById('maxCargoSlots').textContent = maxSlots;
            
            const sectionTitle = document.getElementById('cargoSectionTitle');
            if (sectionTitle) {
                sectionTitle.textContent = `📦 화물 선택 (최대 ${maxSlots}개)`;
            }
            
            Object.keys(CARGO_TYPES).forEach(cargoType => {
                const card = document.querySelector(`[data-cargo="${cargoType}"]`);
                const statusElement = document.getElementById(`${cargoType}-status`);
                
                if (card && statusElement) {
                    const isSelected = gameState.selectedCargos.includes(cargoType);
                    const canSelect = gameState.selectedCargos.length < maxSlots;
                    
                    if (isSelected) {
                        card.classList.add('selected');
                        statusElement.textContent = '✓ 선택됨';
                        card.style.opacity = '1';
                        card.style.cursor = 'pointer';
                    } else {
                        card.classList.remove('selected');
                        statusElement.textContent = '선택 안됨';
                        
                        if (canSelect) {
                            card.style.opacity = '1';
                            card.style.cursor = 'pointer';
                        } else {
                            card.style.opacity = '0.5';
                            card.style.cursor = 'not-allowed';
                        }
                    }
                }
            });
            
            let effectText = '';
            let totalDiamonds = 0;
            let totalGold = 0;
            
            if (gameState.selectedCargos.length > 0) {
                gameState.selectedCargos.forEach(cargoType => {
                    const cargo = CARGO_TYPES[cargoType];
                    effectText += `${cargo.name}: ${cargo.description}<br>`;
                    
                    if (cargoType === 'food') {
                        totalGold += cargo.baseReward;
                    } else {
                        totalDiamonds += cargo.baseReward;
                    }
                });
                effectText += `<strong>💎 다이아: ${totalDiamonds} | 💰 골드: ${totalGold}</strong>`;
            } else {
                effectText = '화물을 선택해주세요';
            }
            
            const effectElement = document.getElementById('cargoEffectText');
            if (effectElement) {
                effectElement.innerHTML = effectText;
            }
            
            updateStartButton();
        }
        
        function updateStartButton() {
            const canStart = gameState.environment && gameState.selectedDestination && gameState.selectedCargos.length > 0;
            const startBtn = document.getElementById('startMissionBtn');
            if (startBtn) {
                startBtn.disabled = !canStart;
            }
        }

        function getBrowserAbbrev() {
            const ua = navigator.userAgent;
            if (ua.includes('Chrome') && !ua.includes('Edge') && !ua.includes('OPR')) return 'CH';
            if (ua.includes('Safari') && !ua.includes('Chrome')) return 'SA';
            if (ua.includes('Firefox')) return 'FF';
            if (ua.includes('Edg') || ua.includes('Edge')) return 'ED';
            return 'OT';
        }

        function updateEnvIndicator() {
            const envText = gameState.environment ? (gameState.environment === 'pc' ? 'PC' : 'MB') : '--';
            const indicator = document.getElementById('envIndicator');
            if (indicator) indicator.textContent = `${getBrowserAbbrev()}/${envText}`;
        }

        function applyEnvironment(env) {
            gameState.environment = env;
            if (env === 'pc') {
                canvas.width = 1280;
                canvas.height = 760;
                document.getElementById('touchControls').style.display = 'none';
            } else if (env === 'mobile') {
                canvas.width = 800;
                canvas.height = 450;
                setupMobileControls();
            }
            document.getElementById('gameInfo').style.width = canvas.width + 'px';
            document.getElementById('selectedEnvDisplay').textContent = env === 'pc' ? 'PC' : '모바일';
            updateEnvIndicator();
            updateStartButton();
        }

        function setupMobileControls() {
            const controls = document.getElementById('touchControls');
            controls.style.display = 'block';
            if (mobileControlsInitialized) return;
            mobileControlsInitialized = true;
            const map = {
                'btn-left': 'arrowleft',
                'btn-right': 'arrowright',
                'btn-up': 'arrowup',
                'btn-down': 'arrowdown'
            };
            Object.keys(map).forEach(id => {
                const key = map[id];
                const btn = document.getElementById(id);
                btn.addEventListener('touchstart', e => { e.preventDefault(); gameState.keys[key] = true; });
                const end = e => { e.preventDefault(); gameState.keys[key] = false; };
                btn.addEventListener('touchend', end);
                btn.addEventListener('touchcancel', end);
            });
            const fireBtn = document.getElementById('btn-fire');
            fireBtn.addEventListener('touchstart', e => { e.preventDefault(); shoot(); });
        }
        
        // 영구 업그레이드 함수들
        function getMaxCargoSlots() {
            return 2 + (gameState.cargoCapacityLevel - 1);
        }
        
        function getMaxTurretCount() {
            return 7 + (gameState.maxTurretLevel - 1) * 2;
        }
        
        function getShipSpeedBonus() {
            return (gameState.shipSpeedLevel - 1) * 15;
        }
        
        function upgradeShipSpeed() {
            const cost = 5 + (gameState.shipSpeedLevel - 1) * 3;
            if (gameState.diamonds >= cost) {
                gameState.diamonds -= cost;
                gameState.shipSpeedLevel++;
                playUpgradeSound();
                updatePrepUI();
            }
        }
        
        function upgradeMaxTurrets() {
            const cost = 8 + (gameState.maxTurretLevel - 1) * 5;
            if (gameState.diamonds >= cost) {
                gameState.diamonds -= cost;
                gameState.maxTurretLevel++;
                playUpgradeSound();
                updatePrepUI();
            }
        }
        
        function upgradeCargoCapacity() {
            const cost = 10 + (gameState.cargoCapacityLevel - 1) * 7;
            if (gameState.diamonds >= cost) {
                gameState.diamonds -= cost;
                gameState.cargoCapacityLevel++;
                playUpgradeSound();
                updatePrepUI();
            }
        }

        function unlockMines() {
            const cost = 20;
            if (gameState.diamonds >= cost && gameState.mineLevel === 0) {
                gameState.diamonds -= cost;
                gameState.mineLevel = 1;
                playUpgradeSound();
                updatePrepUI();
            }
        }

        function updatePrepUI() {
            document.getElementById('prepGold').textContent = gameState.gold;
            document.getElementById('prepDiamonds').textContent = gameState.diamonds;
            document.getElementById('prepStage').textContent = gameState.stage;
            document.getElementById('selectedEnvDisplay').textContent = gameState.environment ? (gameState.environment === 'pc' ? 'PC' : '모바일') : '없음';
            
            if (gameState.selectedDestination) {
                const dest = DESTINATIONS[gameState.selectedDestination];
                document.getElementById('destinationInfo').style.display = 'block';
                document.getElementById('selectedDestName').textContent = dest.name;
                document.getElementById('selectedDestDesc').textContent = dest.description;
            } else {
                document.getElementById('destinationInfo').style.display = 'none';
            }
            
            document.getElementById('shipSpeedLevel').textContent = gameState.shipSpeedLevel;
            document.getElementById('speedBonus').textContent = getShipSpeedBonus();
            document.getElementById('maxTurretLevel').textContent = gameState.maxTurretLevel;
            document.getElementById('maxTurrets').textContent = getMaxTurretCount();
            document.getElementById('cargoCapacityLevel').textContent = gameState.cargoCapacityLevel;
            document.getElementById('cargoSlotBonus').textContent = getMaxCargoSlots() - 2;
            document.getElementById('mineUpgradeOwned').textContent = gameState.mineLevel > 0 ? '예' : '아니오';

            const speedCost = 5 + (gameState.shipSpeedLevel - 1) * 3;
            const turretCost = 8 + (gameState.maxTurretLevel - 1) * 5;
            const cargoCost = 10 + (gameState.cargoCapacityLevel - 1) * 7;
            const mineCost = 20;

            document.getElementById('speedUpgradeCost').textContent = speedCost;
            document.getElementById('turretUpgradeCost').textContent = turretCost;
            document.getElementById('cargoUpgradeCost').textContent = cargoCost;
            document.getElementById('mineUpgradeCost').textContent = mineCost;

            const speedBtn = document.querySelector('[onclick="upgradeShipSpeed()"]');
            const turretBtn = document.querySelector('[onclick="upgradeMaxTurrets()"]');
            const cargoBtn = document.querySelector('[onclick="upgradeCargoCapacity()"]');
            const mineBtn = document.querySelector('[onclick="unlockMines()"]');

            if (speedBtn) speedBtn.disabled = gameState.diamonds < speedCost;
            if (turretBtn) turretBtn.disabled = gameState.diamonds < turretCost;
            if (cargoBtn) cargoBtn.disabled = gameState.diamonds < cargoCost;
            if (mineBtn) mineBtn.disabled = gameState.diamonds < mineCost || gameState.mineLevel > 0;

            updateCargoUI();
            updateStartButton();
        }
        
        function startMission() {
            if (!gameState.environment) {
                alert('환경을 선택해주세요!');
                return;
            }
            if (!gameState.selectedDestination || gameState.selectedCargos.length === 0) {
                alert('목적지와 화물을 선택해주세요!');
                return;
            }
            
            console.log('배송 미션 시작!');
            
            if (!audioContext) {
                initAudio();
            }
            
            initializeGame();
            
            document.getElementById('prepScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            gameState.inGame = true;
            gameState.gameOver = false;
            gameState.stageComplete = false;
            gameState.lastTimerUpdate = Date.now();
            
            if (!gameLoopRunning) {
                gameLoopRunning = true;
                gameLoop();
            }
        }
        
        function returnToPrep() {
            console.log('준비화면으로 복귀');
            
            if (gameState.gameOver) {
                gameState.damageLevel = 1;
                gameState.speedLevel = 1;
                gameState.turretCount = 1;
                gameState.selectedCargos = [];
                gameState.score = 0;
                gameState.stage = 1;
                gameState.selectedDestination = null;
            }
            
            document.getElementById('prepScreen').style.display = 'block';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('stageCompleteScreen').style.display = 'none';

            gameState.inGame = false;
            gameState.gameOver = false;
            gameState.environment = null;
            document.getElementById('touchControls').style.display = 'none';
            canvas.width = 1280;
            canvas.height = 760;
            document.getElementById('gameInfo').style.width = canvas.width + 'px';
            updateEnvIndicator();
            updateStartButton();

            document.querySelectorAll('.destination-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('.cargo-type-card').forEach(card => {
                card.classList.remove('selected');
                card.style.opacity = '1';
                card.style.cursor = 'pointer';
            });

            bullets = [];
            turretBullets = [];
            enemyBullets = [];
            enemies = [];
            explosions = [];
            mines = [];

            updatePrepUI();
        }
        
        function initializeGame() {
            const destination = DESTINATIONS[gameState.selectedDestination];
            gameState.stageTimer = destination.time;
            
            player.x = 640;
            player.y = 600;
            
            let totalSpeedBonus = 0;
            let totalSpeedPenalty = 0;
            let bonusLives = 0;
            let damageMultiplier = 1;
            let fireRateMultiplier = 1;
            
            gameState.selectedCargos.forEach(cargoType => {
                const cargo = CARGO_TYPES[cargoType];
                const effects = cargo.effects;
                
                if (effects.speedBonus) totalSpeedBonus += effects.speedBonus;
                if (effects.speedPenalty) totalSpeedPenalty += effects.speedPenalty;
                if (effects.bonusLife) bonusLives += effects.bonusLife;
                if (effects.damageBonus) damageMultiplier += effects.damageBonus;
                if (effects.fireRateBonus) fireRateMultiplier += effects.fireRateBonus;
            });
            
            const baseSpeed = 4;
            const speedBonus = getShipSpeedBonus() / 100;
            player.baseSpeed = baseSpeed * (1 + speedBonus);
            
            const finalSpeedMultiplier = (1 + totalSpeedBonus) * (1 - totalSpeedPenalty);
            player.speed = player.baseSpeed * finalSpeedMultiplier;
            
            gameState.lives = 3 + bonusLives;
            
            player.turrets = [];
            for (let i = 0; i < gameState.turretCount; i++) {
                const positions = [
                    { x: 0, y: -20 },
                    { x: -40, y: -10 },
                    { x: 40, y: -10 },
                    { x: -60, y: 0 },
                    { x: 60, y: 0 },
                    { x: -80, y: 10 },
                    { x: 80, y: 10 },
                    { x: -100, y: 20 },
                    { x: 100, y: 20 },
                    { x: -120, y: 30 },
                    { x: 120, y: 30 }
                ];
                
                if (i < positions.length) {
                    const baseFireRate = Math.max(100, 500 - (gameState.speedLevel - 1) * 50);
                    const finalFireRate = baseFireRate / fireRateMultiplier;
                    
                    player.turrets.push({
                        x: positions[i].x,
                        y: positions[i].y,
                        lastShot: 0,
                        fireRate: finalFireRate,
                        damage: gameState.damageLevel * damageMultiplier
                    });
                }
            }
            
            bullets = [];
            turretBullets = [];
            enemyBullets = [];
            enemies = [];
            explosions = [];
            mines = [];
            gameState.lastMineTime = 0;

            if (stars.length === 0) createStars();
        }
        
        function addTurret() {
            const maxTurrets = getMaxTurretCount();
            if (gameState.gold >= 100 && gameState.turretCount < maxTurrets) {
                gameState.gold -= 100;
                gameState.turretCount++;
                playUpgradeSound();
                
                const positions = [
                    { x: 0, y: -20 },
                    { x: -40, y: -10 },
                    { x: 40, y: -10 },
                    { x: -60, y: 0 },
                    { x: 60, y: 0 },
                    { x: -80, y: 10 },
                    { x: 80, y: 10 },
                    { x: -100, y: 20 },
                    { x: 100, y: 20 },
                    { x: -120, y: 30 },
                    { x: 120, y: 30 }
                ];
                
                if (player.turrets.length < positions.length) {
                    const fireRate = Math.max(100, 500 - (gameState.speedLevel - 1) * 50);
                    player.turrets.push({
                        x: positions[player.turrets.length].x,
                        y: positions[player.turrets.length].y,
                        lastShot: 0,
                        fireRate: fireRate,
                        damage: gameState.damageLevel
                    });
                }
            }
        }
        
        function upgradeDamage() {
            const cost = 50 + (gameState.damageLevel - 1) * 25;
            if (gameState.gold >= cost) {
                gameState.gold -= cost;
                gameState.damageLevel++;
                playUpgradeSound();
                
                player.turrets.forEach(turret => {
                    turret.damage = gameState.damageLevel;
                });
            }
        }
        
        function upgradeSpeed() {
            const cost = 75 + (gameState.speedLevel - 1) * 25;
            if (gameState.gold >= cost) {
                gameState.gold -= cost;
                gameState.speedLevel++;
                playUpgradeSound();
                
                const newFireRate = Math.max(100, 500 - (gameState.speedLevel - 1) * 50);
                player.turrets.forEach(turret => {
                    turret.fireRate = newFireRate;
                });
            }
        }
        
        function updateTurrets() {
            const now = Date.now();
            
            player.turrets.forEach(turret => {
                if (now - turret.lastShot > turret.fireRate && enemies.length > 0) {
                    let closestEnemy = null;
                    let closestDistance = Infinity;
                    
                    enemies.forEach(enemy => {
                        const turretWorldX = player.x + player.width/2 + turret.x;
                        const turretWorldY = player.y + turret.y;
                        const distance = Math.sqrt(
                            Math.pow(enemy.x + enemy.width/2 - turretWorldX, 2) +
                            Math.pow(enemy.y + enemy.height/2 - turretWorldY, 2)
                        );
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEnemy = enemy;
                        }
                    });
                    
                    if (closestEnemy && closestDistance < 400) {
                        const turretWorldX = player.x + player.width/2 + turret.x;
                        const turretWorldY = player.y + turret.y;
                        
                        const dx = closestEnemy.x + closestEnemy.width/2 - turretWorldX;
                        const dy = closestEnemy.y + closestEnemy.height/2 - turretWorldY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        turretBullets.push({
                            x: turretWorldX,
                            y: turretWorldY,
                            width: 4,
                            height: 8,
                            vx: (dx / distance) * 8,
                            vy: (dy / distance) * 8,
                            color: '#ff6600',
                            damage: turret.damage
                        });
                        
                        playTurretSound();
                        turret.lastShot = now;
                    }
                }
            });
        }
        
        function createStars() {
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    speed: -(Math.random() * 0.5 + 0.1)
                });
            }
        }
        
        document.addEventListener('keydown', (e) => {
            if (gameState.inGame) {
                gameState.keys[e.key.toLowerCase()] = true;
                if (e.key === ' ') {
                    e.preventDefault();
                    shoot();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (gameState.inGame) {
                gameState.keys[e.key.toLowerCase()] = false;
            }
        });

        canvas.addEventListener('click', (e) => {
            if (gameState.inGame && gameState.mineLevel > 0) {
                const now = Date.now();
                if (now - gameState.lastMineTime > 1000) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    mines.push({ x, y, radius: 10 });
                    gameState.lastMineTime = now;
                }
            }
        });

        function shoot() {
            if (!gameState.gameOver && !gameState.stageComplete) {
                bullets.push({
                    x: player.x + player.width / 2,
                    y: player.y,
                    width: 6,
                    height: 15,
                    speed: 7,
                    color: '#ffff00'
                });
                playShootSound();
            }
        }
        
        function spawnEnemy() {
            const now = Date.now();
            
            const destination = DESTINATIONS[gameState.selectedDestination];
            const baseSpawnRate = 1500;
            let adjustedSpawnRate = baseSpawnRate / destination.difficulty;
            
            // 군사 물자 효과 적용
            if (gameState.selectedCargos.includes('military')) {
                adjustedSpawnRate /= 1.3;
            }
            
            if (now - gameState.lastEnemySpawn > adjustedSpawnRate - gameState.stage * 100) {
                const spawnSide = Math.random();
                let enemyX, enemyY;
                
                if (spawnSide < 0.7) {
                    enemyX = Math.random() * canvas.width;
                    enemyY = -30;
                } else {
                    if (Math.random() < 0.5) {
                        enemyX = -30;
                        enemyY = Math.random() * canvas.height * 0.6;
                    } else {
                        enemyX = canvas.width + 30;
                        enemyY = Math.random() * canvas.height * 0.6;
                    }
                }
                
                const roll = Math.random();
                let enemy;

                if (gameState.stage >= 3 && roll > 0.95) {
                    enemy = {
                        x: enemyX,
                        y: enemyY,
                        width: 60,
                        height: 60,
                        speed: (0.5 + gameState.stage * 0.1) * destination.difficulty,
                        color: '#00aaff',
                        type: 'carrier',
                        hp: Math.ceil(15 * destination.difficulty + gameState.stage * 5),
                        maxHp: Math.ceil(15 * destination.difficulty + gameState.stage * 5),
                        goldValue: 50 + gameState.stage * 5,
                        lastSpawn: now
                    };
                } else if (gameState.stage >= 2 && roll > 0.85) {
                    enemy = {
                        x: enemyX,
                        y: enemyY,
                        width: 40,
                        height: 40,
                        speed: (1 + gameState.stage * 0.1) * destination.difficulty,
                        color: '#00ff00',
                        type: 'cruiser',
                        hp: Math.ceil(5 * destination.difficulty + gameState.stage),
                        maxHp: Math.ceil(5 * destination.difficulty + gameState.stage),
                        goldValue: 25 + gameState.stage * 3,
                        lastShot: now
                    };
                } else if (roll < 0.6) {
                    enemy = {
                        x: enemyX,
                        y: enemyY,
                        width: 25,
                        height: 25,
                        speed: (Math.random() * 1.5 + 1 + gameState.stage * 0.2) * destination.difficulty,
                        color: '#ff6600',
                        type: 'normal',
                        hp: 1,
                        maxHp: 1,
                        goldValue: 5 + gameState.stage
                    };
                } else if (roll < 0.85) {
                    enemy = {
                        x: enemyX,
                        y: enemyY,
                        width: 30,
                        height: 30,
                        speed: (Math.random() * 1.2 + 0.8 + gameState.stage * 0.15) * destination.difficulty,
                        color: '#ff0000',
                        type: 'strong',
                        hp: Math.ceil((2 + Math.floor(gameState.stage / 3)) * destination.difficulty),
                        maxHp: Math.ceil((2 + Math.floor(gameState.stage / 3)) * destination.difficulty),
                        goldValue: 12 + gameState.stage * 2
                    };
                } else {
                    enemy = {
                        x: enemyX,
                        y: enemyY,
                        width: 20,
                        height: 20,
                        speed: (Math.random() * 2 + 2 + gameState.stage * 0.3) * destination.difficulty,
                        color: '#ff00ff',
                        type: 'fast',
                        hp: 1,
                        maxHp: 1,
                        goldValue: 8 + gameState.stage
                    };
                }
                
                enemies.push(enemy);
                gameState.lastEnemySpawn = now;
            }
        }
        
        function createExplosion(x, y) {
            for (let i = 0; i < 8; i++) {
                explosions.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    life: 30, maxLife: 30,
                    color: '#ff8800'
                });
            }
        }
        
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function getScoreValue(enemy, fromTurret = false) {
            if (enemy.type === 'fast') return fromTurret ? 25 : 20;
            if (enemy.type === 'strong') return fromTurret ? 20 : 15;
            if (enemy.type === 'cruiser') return fromTurret ? 35 : 30;
            if (enemy.type === 'carrier') return fromTurret ? 55 : 50;
            return fromTurret ? 15 : 10;
        }
        
        function updatePlayer() {
            if (gameState.keys['a'] || gameState.keys['arrowleft']) {
                player.x = Math.max(0, player.x - player.speed);
            }
            if (gameState.keys['d'] || gameState.keys['arrowright']) {
                player.x = Math.min(canvas.width - player.width, player.x + player.speed);
            }
            if (gameState.keys['w'] || gameState.keys['arrowup']) {
                player.y = Math.max(0, player.y - player.speed);
            }
            if (gameState.keys['s'] || gameState.keys['arrowdown']) {
                player.y = Math.min(canvas.height - player.height, player.y + player.speed);
            }
        }
        
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.y -= bullet.speed;
                return bullet.y > -bullet.height;
            });
            
            turretBullets = turretBullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
               return bullet.x > -50 && bullet.x < canvas.width + 50 &&
                       bullet.y > -50 && bullet.y < canvas.height + 50;
            });
        }

        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                return bullet.x > -50 && bullet.x < canvas.width + 50 &&
                       bullet.y > -50 && bullet.y < canvas.height + 50;
            });
        }
        
        function updateEnemies() {
            const now = Date.now();
            enemies = enemies.filter(enemy => {
                const dx = player.x + player.width/2 - enemy.x;
                const dy = player.y + player.height/2 - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }

                if (enemy.type === 'carrier') {
                    if (now - enemy.lastSpawn > 2000) {
                        enemies.push({
                            x: enemy.x + enemy.width/2,
                            y: enemy.y + enemy.height/2,
                            width: 20,
                            height: 20,
                            speed: 2 + gameState.stage * 0.2,
                            color: '#ffaa00',
                            type: 'drone',
                            hp: 1,
                            maxHp: 1,
                            goldValue: 5 + gameState.stage
                        });
                        enemy.lastSpawn = now;
                    }
                } else if (enemy.type === 'cruiser') {
                    if (now - enemy.lastShot > 1500) {
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        enemyBullets.push({
                            x: enemy.x + enemy.width/2,
                            y: enemy.y + enemy.height/2,
                            vx: (dx / dist) * 4,
                            vy: (dy / dist) * 4,
                            width: 6,
                            height: 6,
                            color: '#ff4444'
                        });
                        enemy.lastShot = now;
                    }
                }

                if (checkCollision(player, enemy)) {
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    playHitSound();
                    gameState.lives--;
                    if (gameState.lives <= 0) {
                        gameState.gameOver = true;
                        showGameOver();
                    }
                    return false;
                }
                
                return enemy.x > -100 && enemy.x < canvas.width + 100 &&
                       enemy.y > -100 && enemy.y < canvas.height + 100;
            });
        }

        function updateMines() {
            mines = mines.filter(mine => {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    const dx = enemy.x + enemy.width/2 - mine.x;
                    const dy = enemy.y + enemy.height/2 - mine.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 20) {
                        createExplosion(mine.x, mine.y);
                        playExplosionSound();
                        gameState.score += getScoreValue(enemy);
                        gameState.gold += enemy.goldValue;
                        enemies.splice(i, 1);
                        return false;
                    }
                }
                return true;
            });
        }

        function checkBulletEnemyCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(bullets[i], enemies[j])) {
                        enemies[j].hp -= 1;
                        bullets.splice(i, 1);

                        if (enemies[j].hp <= 0) {
                            createExplosion(enemies[j].x + enemies[j].width/2, enemies[j].y + enemies[j].height/2);
                            playExplosionSound();
                            gameState.score += getScoreValue(enemies[j]);
                            gameState.gold += enemies[j].goldValue;
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
            
            for (let i = turretBullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    if (checkCollision(turretBullets[i], enemies[j])) {
                        enemies[j].hp -= turretBullets[i].damage;
                        turretBullets.splice(i, 1);

                        if (enemies[j].hp <= 0) {
                            createExplosion(enemies[j].x + enemies[j].width/2, enemies[j].y + enemies[j].height/2);
                            playExplosionSound();
                            gameState.score += getScoreValue(enemies[j], true);
                            gameState.gold += enemies[j].goldValue + 2;
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                if (checkCollision(enemyBullets[i], player)) {
                    createExplosion(enemyBullets[i].x, enemyBullets[i].y);
                    playHitSound();
                    gameState.lives--;
                    enemyBullets.splice(i, 1);
                    if (gameState.lives <= 0) {
                        gameState.gameOver = true;
                        showGameOver();
                    }
                    continue;
                }
                let destroyed = false;
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (checkCollision(enemyBullets[i], bullets[j])) {
                        createExplosion(enemyBullets[i].x, enemyBullets[i].y);
                        bullets.splice(j, 1);
                        enemyBullets.splice(i, 1);
                        destroyed = true;
                        break;
                    }
                }
                if (destroyed) continue;
                for (let j = turretBullets.length - 1; j >= 0; j--) {
                    if (checkCollision(enemyBullets[i], turretBullets[j])) {
                        createExplosion(enemyBullets[i].x, enemyBullets[i].y);
                        turretBullets.splice(j, 1);
                        enemyBullets.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        function updateExplosions() {
            explosions = explosions.filter(explosion => {
                explosion.x += explosion.vx;
                explosion.y += explosion.vy;
                explosion.life--;
                return explosion.life > 0;
            });
        }
        
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y < 0) {
                    star.y = canvas.height;
                    star.x = Math.random() * canvas.width;
                }
            });
        }
        
        function updateStageTimer() {
            const now = Date.now();
            if (now - gameState.lastTimerUpdate > 1000) {
                gameState.stageTimer--;
                gameState.lastTimerUpdate = now;
                
                if (gameState.stageTimer <= 0) {
                    completeStage();
                }
            }
        }
        
        function completeStage() {
            gameState.stageComplete = true;
            
            const destination = DESTINATIONS[gameState.selectedDestination];
            const baseGoldReward = 50;
            
            let totalDiamondReward = 0;
            let totalGoldReward = 0;
            let cargoNames = [];
            
            gameState.selectedCargos.forEach(cargoType => {
                const cargo = CARGO_TYPES[cargoType];
                cargoNames.push(cargo.name);
                
                let reward = cargo.baseReward;
                
                // 고급품 효과 적용
                if (cargoType === 'luxury' && gameState.selectedCargos.includes('luxury')) {
                    reward *= 2;
                }
                
                if (cargoType === 'food') {
                    totalGoldReward += reward;
                } else {
                    totalDiamondReward += reward;
                }
            });
            
            const finalGoldReward = Math.floor((baseGoldReward + totalGoldReward) * destination.rewards.goldMultiplier);
            const finalDiamondReward = Math.floor(totalDiamondReward * destination.rewards.diamondMultiplier);
            
            gameState.gold += finalGoldReward;
            gameState.diamonds += finalDiamondReward;
            gameState.stage++;
            
            playStageCompleteSound();
            
            document.getElementById('completedCargo').textContent = cargoNames.length > 0 ? cargoNames.join(', ') : '없음';
            document.getElementById('rewardGold').textContent = finalGoldReward;
            document.getElementById('rewardDiamonds').textContent = finalDiamondReward;
            document.getElementById('stageCompleteScreen').style.display = 'block';
        }
        
        function showGameOver() {
            gameState.gold = 0;
            
            playGameOverSound();
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('failedStage').textContent = gameState.stage;
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        function updateUI() {
            if (gameState.inGame) {
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('gold').textContent = gameState.gold;
                document.getElementById('lives').textContent = gameState.lives;
                document.getElementById('timer').textContent = gameState.stageTimer;
                document.getElementById('gameCargoInfo').textContent = gameState.selectedCargos.length > 0 ? 
                    gameState.selectedCargos.map(type => CARGO_TYPES[type].name.split(' ')[0]).join(' ') : '없음';
                document.getElementById('turrets').textContent = player.turrets.length;
                
                const damageCost = 50 + (gameState.damageLevel - 1) * 25;
                const speedCost = 75 + (gameState.speedLevel - 1) * 25;
                
                document.getElementById('damageCost').textContent = damageCost + '골드';
                document.getElementById('speedCost').textContent = speedCost + '골드';
                
                const maxTurrets = getMaxTurretCount();
                const turretBtn = document.querySelector('#upgradePanel button:nth-child(1)');
                const damageBtn = document.querySelector('#upgradePanel button:nth-child(2)');
                const speedBtn = document.querySelector('#upgradePanel button:nth-child(3)');
                
                if (turretBtn) turretBtn.disabled = gameState.gold < 100 || gameState.turretCount >= maxTurrets;
                if (damageBtn) damageBtn.disabled = gameState.gold < damageCost;
                if (speedBtn) speedBtn.disabled = gameState.gold < speedCost;
            }
        }
        
        function drawStars() {
            ctx.fillStyle = 'white';
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(player.x + player.width/2 - 8, player.y - 10, 16, 15);
            
            const cargoCount = gameState.selectedCargos.length;
            for (let i = 0; i < cargoCount; i++) {
                const boxX = player.x + 30 + (i % 5) * 20;
                const boxY = player.y + 60 + Math.floor(i / 5) * 20;
                
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(boxX, boxY, 15, 15);
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 1;
                ctx.strokeRect(boxX, boxY, 15, 15);
            }
            
            player.turrets.forEach(turret => {
                const turretX = player.x + player.width/2 + turret.x;
                const turretY = player.y + turret.y;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(turretX, turretY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(turretX, turretY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            
            turretBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.shadowColor = bullet.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            enemyBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function drawMines() {
            mines.forEach(mine => {
                ctx.fillStyle = '#aaaa00';
                ctx.beginPath();
                ctx.arc(mine.x, mine.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawEnemies() {
            enemies.forEach(enemy => {
                const hpRatio = enemy.hp / enemy.maxHp;
                let baseColor = enemy.color;
                
                if (hpRatio < 1) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${1 - hpRatio + 0.3})`;
                } else {
                    ctx.fillStyle = baseColor;
                }
                
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                if (enemy.type === 'strong') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(enemy.x + 3, enemy.y + 3, enemy.width - 6, enemy.height - 6);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x + 6, enemy.y + 6, enemy.width - 12, enemy.height - 12);
                } else if (enemy.type === 'fast') {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(enemy.x + 2, enemy.y + 2, enemy.width - 4, enemy.height - 4);
                }
                
                if (enemy.hp < enemy.maxHp) {
                    const barWidth = enemy.width;
                    const barHeight = 3;
                    const barY = enemy.y - 8;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x, barY, barWidth, barHeight);
                    
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(enemy.x, barY, (enemy.hp / enemy.maxHp) * barWidth, barHeight);
                }
                
                ctx.fillStyle = '#ffdd00';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${enemy.goldValue}G`, enemy.x + enemy.width/2, enemy.y + enemy.height + 15);
                
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.3, enemy.y + enemy.height * 0.3, 2, 0, Math.PI * 2);
                ctx.arc(enemy.x + enemy.width * 0.7, enemy.y + enemy.height * 0.3, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.3, enemy.y + enemy.height * 0.3, 1, 0, Math.PI * 2);
                ctx.arc(enemy.x + enemy.width * 0.7, enemy.y + enemy.height * 0.3, 1, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawExplosions() {
            explosions.forEach(explosion => {
                const alpha = explosion.life / explosion.maxLife;
                ctx.fillStyle = explosion.color;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });
        }
        
        function gameLoop() {
            if (!gameState.inGame) {
                gameLoopRunning = false;
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.gameOver && !gameState.stageComplete) {
                updateStars();
                updatePlayer();
                updateBullets();
                updateEnemyBullets();
                updateEnemies();
                updateMines();
                updateExplosions();
                updateTurrets();
                updateStageTimer();
                
                spawnEnemy();
                checkBulletEnemyCollisions();
            }
            
            drawStars();
            drawPlayer();
            drawBullets();
            drawMines();
            drawEnemies();
            drawExplosions();
            
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // 초기화
        updatePrepUI();
        updateEnvIndicator();
    </script>
</body>
</html>